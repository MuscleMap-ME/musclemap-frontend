/**
 * Geo Hangouts Service
 *
 * Handles location-based community features:
 * - User location tracking (with privacy controls)
 * - Automatic hangout creation based on location clusters
 * - Distance-based member sorting
 * - Local leaderboards
 * - Hangout challenges and events
 *
 * Users feel at home in their local community!
 */

import crypto from 'crypto';
import { queryOne, queryAll, query } from '../../db/client';
import { loggers } from '../../lib/logger';

const log = loggers.social;

// Distance calculation constants
const EARTH_RADIUS_MILES = 3958.8;

// Hangout radius tiers in miles
const HANGOUT_RADIUS = 25;
const DISTANCE_TIERS = {
  neighbor: 5,
  local: 15,
  regional: 50,
  extended: 100,
};

export interface UserLocation {
  userId: string;
  latitude: number;
  longitude: number;
  accuracyMeters?: number;
  city?: string;
  stateProvince?: string;
  country?: string;
  postalCode?: string;
  timezone?: string;
  shareExact: boolean;
  shareCity: boolean;
  visibleInHangout: boolean;
  updatedAt: Date;
}

export interface GeoHangout {
  id: string;
  name: string;
  centerLatitude: number;
  centerLongitude: number;
  radiusMiles: number;
  city?: string;
  stateProvince?: string;
  country?: string;
  memberCount: number;
  activeToday: number;
  activeThisWeek: number;
  autoGenerated: boolean;
  enabled: boolean;
  createdAt: Date;
}

export interface HangoutMember {
  userId: string;
  username: string;
  displayName?: string;
  wealthTier: number;
  distanceMiles: number;
  distanceTier: 'neighbor' | 'local' | 'regional' | 'extended';
  isPrimary: boolean;
  lastActiveAt?: Date;
  city?: string;
}

export interface HangoutChallenge {
  id: string;
  hangoutId?: string;
  name: string;
  description?: string;
  challengeType: string;
  metricKey?: string;
  startsAt: Date;
  endsAt: Date;
  basePrize: number;
  contributedPrize: number;
  totalPrize: number;
  entryFee: number;
  maxParticipants?: number;
  participantCount: number;
  status: 'upcoming' | 'active' | 'completed' | 'cancelled';
  createdBy?: string;
}

export interface HangoutEvent {
  id: string;
  hangoutId: string;
  createdBy: string;
  title: string;
  description?: string;
  startsAt: Date;
  endsAt?: Date;
  locationType: 'in_person' | 'virtual' | 'hybrid';
  locationName?: string;
  locationAddress?: string;
  maxAttendees?: number;
  attendeesCount: number;
  isFeatured: boolean;
  status: 'draft' | 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
}

export const geoHangoutsService = {
  /**
   * Calculate distance between two coordinates using Haversine formula
   */
  calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const toRad = (deg: number) => deg * (Math.PI / 180);

    const dLat = toRad(lat2 - lat1);
    const dLng = toRad(lng2 - lng1);

    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return EARTH_RADIUS_MILES * c;
  },

  /**
   * Get distance tier based on miles
   */
  getDistanceTier(miles: number): 'neighbor' | 'local' | 'regional' | 'extended' {
    if (miles < DISTANCE_TIERS.neighbor) return 'neighbor';
    if (miles < DISTANCE_TIERS.local) return 'local';
    if (miles < DISTANCE_TIERS.regional) return 'regional';
    return 'extended';
  },

  /**
   * Update user's location
   */
  async updateUserLocation(
    userId: string,
    latitude: number,
    longitude: number,
    options: {
      accuracyMeters?: number;
      city?: string;
      stateProvince?: string;
      country?: string;
      postalCode?: string;
      timezone?: string;
      shareExact?: boolean;
      shareCity?: boolean;
      visibleInHangout?: boolean;
    } = {}
  ): Promise<UserLocation> {
    const result = await queryOne<{
      user_id: string;
      latitude: string;
      longitude: string;
      accuracy_meters: number | null;
      city: string | null;
      state_province: string | null;
      country: string | null;
      postal_code: string | null;
      timezone: string | null;
      share_exact: boolean;
      share_city: boolean;
      visible_in_hangout: boolean;
      updated_at: Date;
    }>(
      `INSERT INTO user_locations (user_id, latitude, longitude, accuracy_meters, city, state_province, country, postal_code, timezone, share_exact, share_city, visible_in_hangout, updated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW())
       ON CONFLICT (user_id) DO UPDATE SET
         latitude = EXCLUDED.latitude,
         longitude = EXCLUDED.longitude,
         accuracy_meters = COALESCE(EXCLUDED.accuracy_meters, user_locations.accuracy_meters),
         city = COALESCE(EXCLUDED.city, user_locations.city),
         state_province = COALESCE(EXCLUDED.state_province, user_locations.state_province),
         country = COALESCE(EXCLUDED.country, user_locations.country),
         postal_code = COALESCE(EXCLUDED.postal_code, user_locations.postal_code),
         timezone = COALESCE(EXCLUDED.timezone, user_locations.timezone),
         share_exact = COALESCE(EXCLUDED.share_exact, user_locations.share_exact),
         share_city = COALESCE(EXCLUDED.share_city, user_locations.share_city),
         visible_in_hangout = COALESCE(EXCLUDED.visible_in_hangout, user_locations.visible_in_hangout),
         updated_at = NOW()
       RETURNING *`,
      [
        userId,
        latitude,
        longitude,
        options.accuracyMeters || null,
        options.city || null,
        options.stateProvince || null,
        options.country || null,
        options.postalCode || null,
        options.timezone || null,
        options.shareExact ?? false,
        options.shareCity ?? true,
        options.visibleInHangout ?? true,
      ]
    );

    if (!result) throw new Error('Failed to update location');

    // Auto-assign to nearest hangout
    await this.assignUserToNearestHangout(userId, latitude, longitude);

    return {
      userId: result.user_id,
      latitude: parseFloat(result.latitude),
      longitude: parseFloat(result.longitude),
      accuracyMeters: result.accuracy_meters || undefined,
      city: result.city || undefined,
      stateProvince: result.state_province || undefined,
      country: result.country || undefined,
      postalCode: result.postal_code || undefined,
      timezone: result.timezone || undefined,
      shareExact: result.share_exact,
      shareCity: result.share_city,
      visibleInHangout: result.visible_in_hangout,
      updatedAt: result.updated_at,
    };
  },

  /**
   * Get user's location
   */
  async getUserLocation(userId: string): Promise<UserLocation | null> {
    const row = await queryOne<{
      user_id: string;
      latitude: string | null;
      longitude: string | null;
      accuracy_meters: number | null;
      city: string | null;
      state_province: string | null;
      country: string | null;
      postal_code: string | null;
      timezone: string | null;
      share_exact: boolean;
      share_city: boolean;
      visible_in_hangout: boolean;
      updated_at: Date;
    }>('SELECT * FROM user_locations WHERE user_id = $1', [userId]);

    if (!row || !row.latitude || !row.longitude) return null;

    return {
      userId: row.user_id,
      latitude: parseFloat(row.latitude),
      longitude: parseFloat(row.longitude),
      accuracyMeters: row.accuracy_meters || undefined,
      city: row.city || undefined,
      stateProvince: row.state_province || undefined,
      country: row.country || undefined,
      postalCode: row.postal_code || undefined,
      timezone: row.timezone || undefined,
      shareExact: row.share_exact,
      shareCity: row.share_city,
      visibleInHangout: row.visible_in_hangout,
      updatedAt: row.updated_at,
    };
  },

  /**
   * Find or create a hangout for a location
   */
  async findOrCreateHangout(
    latitude: number,
    longitude: number,
    city?: string,
    stateProvince?: string,
    country?: string
  ): Promise<GeoHangout> {
    // First try to find an existing hangout within radius
    const existing = await queryOne<{
      id: string;
      name: string;
      center_latitude: string;
      center_longitude: string;
      radius_miles: number;
      city: string | null;
      state_province: string | null;
      country: string | null;
      member_count: number;
      active_today: number;
      active_this_week: number;
      auto_generated: boolean;
      enabled: boolean;
      created_at: Date;
    }>(
      `SELECT * FROM geo_hangouts
       WHERE enabled = true
       ORDER BY (
         (center_latitude - $1) * (center_latitude - $1) +
         (center_longitude - $2) * (center_longitude - $2)
       )
       LIMIT 1`,
      [latitude, longitude]
    );

    if (existing) {
      const distance = this.calculateDistance(
        latitude,
        longitude,
        parseFloat(existing.center_latitude),
        parseFloat(existing.center_longitude)
      );

      if (distance <= existing.radius_miles) {
        return {
          id: existing.id,
          name: existing.name,
          centerLatitude: parseFloat(existing.center_latitude),
          centerLongitude: parseFloat(existing.center_longitude),
          radiusMiles: existing.radius_miles,
          city: existing.city || undefined,
          stateProvince: existing.state_province || undefined,
          country: existing.country || undefined,
          memberCount: existing.member_count,
          activeToday: existing.active_today,
          activeThisWeek: existing.active_this_week,
          autoGenerated: existing.auto_generated,
          enabled: existing.enabled,
          createdAt: existing.created_at,
        };
      }
    }

    // Create a new hangout
    const name = city
      ? `${city} Fitness Crew`
      : stateProvince
        ? `${stateProvince} Fitness Crew`
        : `Local Fitness Crew`;

    const id = `geo_${crypto.randomBytes(12).toString('hex')}`;

    await query(
      `INSERT INTO geo_hangouts (id, name, center_latitude, center_longitude, radius_miles, city, state_province, country, auto_generated)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, true)`,
      [id, name, latitude, longitude, HANGOUT_RADIUS, city || null, stateProvince || null, country || null]
    );

    log.info({ id, name, latitude, longitude }, 'Created new geo hangout');

    return {
      id,
      name,
      centerLatitude: latitude,
      centerLongitude: longitude,
      radiusMiles: HANGOUT_RADIUS,
      city,
      stateProvince,
      country,
      memberCount: 0,
      activeToday: 0,
      activeThisWeek: 0,
      autoGenerated: true,
      enabled: true,
      createdAt: new Date(),
    };
  },

  /**
   * Assign user to their nearest hangout
   */
  async assignUserToNearestHangout(userId: string, latitude: number, longitude: number): Promise<void> {
    // Get or create the nearest hangout
    const location = await this.getUserLocation(userId);
    const hangout = await this.findOrCreateHangout(
      latitude,
      longitude,
      location?.city,
      location?.stateProvince,
      location?.country
    );

    const distance = this.calculateDistance(
      latitude,
      longitude,
      hangout.centerLatitude,
      hangout.centerLongitude
    );

    // Remove existing primary membership if different
    await query(
      `UPDATE user_hangout_memberships SET is_primary = false
       WHERE user_id = $1 AND is_primary = true AND hangout_id != $2`,
      [userId, hangout.id]
    );

    // Add/update membership
    await query(
      `INSERT INTO user_hangout_memberships (user_id, hangout_id, is_primary, distance_miles, last_active_at)
       VALUES ($1, $2, true, $3, NOW())
       ON CONFLICT (user_id, hangout_id) DO UPDATE SET
         is_primary = true,
         distance_miles = EXCLUDED.distance_miles,
         last_active_at = NOW()`,
      [userId, hangout.id, distance]
    );

    // Update hangout member count
    await query(
      `UPDATE geo_hangouts SET member_count = (
         SELECT COUNT(DISTINCT user_id) FROM user_hangout_memberships WHERE hangout_id = $1
       ) WHERE id = $1`,
      [hangout.id]
    );
  },

  /**
   * Get user's primary hangout
   */
  async getUserPrimaryHangout(userId: string): Promise<GeoHangout | null> {
    const row = await queryOne<{
      id: string;
      name: string;
      center_latitude: string;
      center_longitude: string;
      radius_miles: number;
      city: string | null;
      state_province: string | null;
      country: string | null;
      member_count: number;
      active_today: number;
      active_this_week: number;
      auto_generated: boolean;
      enabled: boolean;
      created_at: Date;
    }>(
      `SELECT h.* FROM geo_hangouts h
       JOIN user_hangout_memberships m ON m.hangout_id = h.id
       WHERE m.user_id = $1 AND m.is_primary = true`,
      [userId]
    );

    if (!row) return null;

    return {
      id: row.id,
      name: row.name,
      centerLatitude: parseFloat(row.center_latitude),
      centerLongitude: parseFloat(row.center_longitude),
      radiusMiles: row.radius_miles,
      city: row.city || undefined,
      stateProvince: row.state_province || undefined,
      country: row.country || undefined,
      memberCount: row.member_count,
      activeToday: row.active_today,
      activeThisWeek: row.active_this_week,
      autoGenerated: row.auto_generated,
      enabled: row.enabled,
      createdAt: row.created_at,
    };
  },

  /**
   * Get hangout members sorted by distance from a user
   */
  async getHangoutMembers(
    hangoutId: string,
    viewerUserId: string,
    options: { limit?: number; offset?: number; onlineOnly?: boolean } = {}
  ): Promise<{ members: HangoutMember[]; total: number }> {
    const { limit = 50, offset = 0, onlineOnly = false } = options;

    // Get viewer's location
    const viewerLocation = await this.getUserLocation(viewerUserId);

    let whereClause = 'WHERE m.hangout_id = $1';
    const params: unknown[] = [hangoutId];

    if (onlineOnly) {
      whereClause += ' AND m.last_active_at > NOW() - INTERVAL \'15 minutes\'';
    }

    // Get members with distance calculation
    const rows = await queryAll<{
      user_id: string;
      username: string;
      display_name: string | null;
      wealth_tier: number;
      is_primary: boolean;
      last_active_at: Date | null;
      city: string | null;
      latitude: string | null;
      longitude: string | null;
      share_exact: boolean;
      visible_in_hangout: boolean;
      distance_miles: string | null;
    }>(
      `SELECT
         m.user_id,
         u.username,
         u.display_name,
         COALESCE(u.wealth_tier, 0) as wealth_tier,
         m.is_primary,
         m.last_active_at,
         l.city,
         l.latitude,
         l.longitude,
         COALESCE(l.share_exact, false) as share_exact,
         COALESCE(l.visible_in_hangout, true) as visible_in_hangout,
         m.distance_miles
       FROM user_hangout_memberships m
       JOIN users u ON u.id = m.user_id
       LEFT JOIN user_locations l ON l.user_id = m.user_id
       ${whereClause}
       ORDER BY m.distance_miles ASC NULLS LAST
       LIMIT $${params.length + 1} OFFSET $${params.length + 2}`,
      [...params, limit, offset]
    );

    // Get total count
    const countResult = await queryOne<{ count: string }>(
      `SELECT COUNT(*) as count FROM user_hangout_memberships m ${whereClause}`,
      params
    );

    const members: HangoutMember[] = [];

    for (const row of rows) {
      if (!row.visible_in_hangout) continue;

      let distanceMiles = parseFloat(row.distance_miles || '0');

      // Calculate distance from viewer if we have coordinates
      if (viewerLocation && row.latitude && row.longitude) {
        distanceMiles = this.calculateDistance(
          viewerLocation.latitude,
          viewerLocation.longitude,
          parseFloat(row.latitude),
          parseFloat(row.longitude)
        );
      }

      members.push({
        userId: row.user_id,
        username: row.username,
        displayName: row.display_name || undefined,
        wealthTier: row.wealth_tier,
        distanceMiles: row.share_exact ? distanceMiles : Math.round(distanceMiles),
        distanceTier: this.getDistanceTier(distanceMiles),
        isPrimary: row.is_primary,
        lastActiveAt: row.last_active_at || undefined,
        city: row.city || undefined,
      });
    }

    // Sort by distance from viewer
    members.sort((a, b) => a.distanceMiles - b.distanceMiles);

    return {
      members,
      total: parseInt(countResult?.count || '0'),
    };
  },

  /**
   * Get hangout by ID
   */
  async getHangout(hangoutId: string): Promise<GeoHangout | null> {
    const row = await queryOne<{
      id: string;
      name: string;
      center_latitude: string;
      center_longitude: string;
      radius_miles: number;
      city: string | null;
      state_province: string | null;
      country: string | null;
      member_count: number;
      active_today: number;
      active_this_week: number;
      auto_generated: boolean;
      enabled: boolean;
      created_at: Date;
    }>('SELECT * FROM geo_hangouts WHERE id = $1', [hangoutId]);

    if (!row) return null;

    return {
      id: row.id,
      name: row.name,
      centerLatitude: parseFloat(row.center_latitude),
      centerLongitude: parseFloat(row.center_longitude),
      radiusMiles: row.radius_miles,
      city: row.city || undefined,
      stateProvince: row.state_province || undefined,
      country: row.country || undefined,
      memberCount: row.member_count,
      activeToday: row.active_today,
      activeThisWeek: row.active_this_week,
      autoGenerated: row.auto_generated,
      enabled: row.enabled,
      createdAt: row.created_at,
    };
  },

  /**
   * Create a hangout challenge
   */
  async createChallenge(
    hangoutId: string | null,
    createdBy: string,
    params: {
      name: string;
      description?: string;
      challengeType: string;
      metricKey?: string;
      startsAt: Date;
      endsAt: Date;
      basePrize?: number;
      entryFee?: number;
      maxParticipants?: number;
    }
  ): Promise<HangoutChallenge> {
    const id = `hc_${crypto.randomBytes(12).toString('hex')}`;

    await query(
      `INSERT INTO hangout_challenges (id, hangout_id, name, description, challenge_type, metric_key, starts_at, ends_at, base_prize, entry_fee, max_participants, created_by, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'upcoming')`,
      [
        id,
        hangoutId,
        params.name,
        params.description || null,
        params.challengeType,
        params.metricKey || null,
        params.startsAt,
        params.endsAt,
        params.basePrize || 0,
        params.entryFee || 0,
        params.maxParticipants || null,
        createdBy,
      ]
    );

    log.info({ id, hangoutId, name: params.name }, 'Created hangout challenge');

    return {
      id,
      hangoutId: hangoutId || undefined,
      name: params.name,
      description: params.description,
      challengeType: params.challengeType,
      metricKey: params.metricKey,
      startsAt: params.startsAt,
      endsAt: params.endsAt,
      basePrize: params.basePrize || 0,
      contributedPrize: 0,
      totalPrize: params.basePrize || 0,
      entryFee: params.entryFee || 0,
      maxParticipants: params.maxParticipants,
      participantCount: 0,
      status: 'upcoming',
      createdBy,
    };
  },

  /**
   * Get hangout challenges
   */
  async getHangoutChallenges(
    hangoutId: string,
    options: { status?: string; limit?: number; offset?: number } = {}
  ): Promise<HangoutChallenge[]> {
    const { status, limit = 20, offset = 0 } = options;

    let whereClause = 'WHERE hangout_id = $1';
    const params: unknown[] = [hangoutId];

    if (status) {
      whereClause += ` AND status = $${params.length + 1}`;
      params.push(status);
    }

    const rows = await queryAll<{
      id: string;
      hangout_id: string | null;
      name: string;
      description: string | null;
      challenge_type: string;
      metric_key: string | null;
      starts_at: Date;
      ends_at: Date;
      base_prize: number;
      contributed_prize: number;
      entry_fee: number;
      max_participants: number | null;
      status: string;
      created_by: string | null;
      participant_count: string; // COUNT() returns string in pg
    }>(
      `SELECT c.*,
         (SELECT COUNT(*) FROM hangout_challenge_participants WHERE challenge_id = c.id) as participant_count
       FROM hangout_challenges c
       ${whereClause}
       ORDER BY starts_at DESC
       LIMIT $${params.length + 1} OFFSET $${params.length + 2}`,
      [...params, limit, offset]
    );

    return rows.map(r => ({
      id: r.id,
      hangoutId: r.hangout_id || undefined,
      name: r.name,
      description: r.description || undefined,
      challengeType: r.challenge_type,
      metricKey: r.metric_key || undefined,
      startsAt: r.starts_at,
      endsAt: r.ends_at,
      basePrize: r.base_prize,
      contributedPrize: r.contributed_prize,
      totalPrize: r.base_prize + r.contributed_prize,
      entryFee: r.entry_fee,
      maxParticipants: r.max_participants || undefined,
      participantCount: parseInt(r.participant_count, 10) || 0,
      status: r.status as HangoutChallenge['status'],
      createdBy: r.created_by || undefined,
    }));
  },

  /**
   * Create a hangout event
   */
  async createEvent(
    hangoutId: string,
    createdBy: string,
    params: {
      title: string;
      description?: string;
      startsAt: Date;
      endsAt?: Date;
      locationType: 'in_person' | 'virtual' | 'hybrid';
      locationName?: string;
      locationAddress?: string;
      maxAttendees?: number;
    }
  ): Promise<HangoutEvent> {
    const id = `he_${crypto.randomBytes(12).toString('hex')}`;

    await query(
      `INSERT INTO hangout_events (id, hangout_id, created_by, title, description, starts_at, ends_at, location_type, location_name, location_address, max_attendees, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 'scheduled')`,
      [
        id,
        hangoutId,
        createdBy,
        params.title,
        params.description || null,
        params.startsAt,
        params.endsAt || null,
        params.locationType,
        params.locationName || null,
        params.locationAddress || null,
        params.maxAttendees || null,
      ]
    );

    log.info({ id, hangoutId, title: params.title }, 'Created hangout event');

    return {
      id,
      hangoutId,
      createdBy,
      title: params.title,
      description: params.description,
      startsAt: params.startsAt,
      endsAt: params.endsAt,
      locationType: params.locationType,
      locationName: params.locationName,
      locationAddress: params.locationAddress,
      maxAttendees: params.maxAttendees,
      attendeesCount: 0,
      isFeatured: false,
      status: 'scheduled',
    };
  },

  /**
   * Get hangout events
   */
  async getHangoutEvents(
    hangoutId: string,
    options: { upcoming?: boolean; limit?: number; offset?: number } = {}
  ): Promise<HangoutEvent[]> {
    const { upcoming = true, limit = 20, offset = 0 } = options;

    let whereClause = 'WHERE hangout_id = $1';
    if (upcoming) {
      whereClause += " AND starts_at > NOW() AND status = 'scheduled'";
    }

    const rows = await queryAll<{
      id: string;
      hangout_id: string;
      created_by: string;
      title: string;
      description: string | null;
      starts_at: Date;
      ends_at: Date | null;
      location_type: string;
      location_name: string | null;
      location_address: string | null;
      max_attendees: number | null;
      attendees_count: number;
      is_featured: boolean;
      status: string;
    }>(
      `SELECT * FROM hangout_events
       ${whereClause}
       ORDER BY starts_at ASC
       LIMIT $2 OFFSET $3`,
      [hangoutId, limit, offset]
    );

    return rows.map(r => ({
      id: r.id,
      hangoutId: r.hangout_id,
      createdBy: r.created_by,
      title: r.title,
      description: r.description || undefined,
      startsAt: r.starts_at,
      endsAt: r.ends_at || undefined,
      locationType: r.location_type as HangoutEvent['locationType'],
      locationName: r.location_name || undefined,
      locationAddress: r.location_address || undefined,
      maxAttendees: r.max_attendees || undefined,
      attendeesCount: r.attendees_count,
      isFeatured: r.is_featured,
      status: r.status as HangoutEvent['status'],
    }));
  },

  /**
   * Update activity stats for a hangout (call periodically)
   */
  async updateActivityStats(hangoutId: string): Promise<void> {
    await query(
      `UPDATE geo_hangouts SET
         active_today = (
           SELECT COUNT(DISTINCT user_id) FROM user_hangout_memberships
           WHERE hangout_id = $1 AND last_active_at >= CURRENT_DATE
         ),
         active_this_week = (
           SELECT COUNT(DISTINCT user_id) FROM user_hangout_memberships
           WHERE hangout_id = $1 AND last_active_at >= DATE_TRUNC('week', CURRENT_DATE)
         ),
         updated_at = NOW()
       WHERE id = $1`,
      [hangoutId]
    );
  },

  /**
   * Record user activity in hangout
   */
  async recordActivity(userId: string, hangoutId: string): Promise<void> {
    await query(
      `UPDATE user_hangout_memberships SET last_active_at = NOW()
       WHERE user_id = $1 AND hangout_id = $2`,
      [userId, hangoutId]
    );
  },
};

export default geoHangoutsService;
