/**
 * Bug Reporter
 * Generate bug reports, file GitHub issues, and update documentation
 */

import type { DiagnosedBug, BugReport, FixResult, BugHunterMetrics } from './types.js';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

// ============================================================================
// BUG REPORTER CLASS
// ============================================================================

export class BugReporter {
  private reportDir: string;
  private projectRoot: string;

  constructor(reportDir: string, projectRoot: string) {
    this.reportDir = reportDir;
    this.projectRoot = projectRoot;
  }

  // ============================================================================
  // GITHUB INTEGRATION
  // ============================================================================

  async createGitHubIssue(bug: DiagnosedBug): Promise<string | null> {
    try {
      const title = this.escapeForShell(bug.title);
      const body = this.escapeForShell(this.generateIssueBody(bug));
      const labels = this.getLabelsForBug(bug).join(',');

      const { stdout } = await execAsync(
        `gh issue create --title "${title}" --body "${body}" --label "${labels}"`,
        { cwd: this.projectRoot }
      );

      // Extract issue URL from output
      const urlMatch = stdout.match(/(https:\/\/github\.com\/[^\s]+)/);
      return urlMatch ? urlMatch[1] : null;
    } catch (error) {
      console.error('Failed to create GitHub issue:', error);
      return null;
    }
  }

  private generateIssueBody(bug: DiagnosedBug): string {
    return `## Bug Report (Auto-Generated by Bug Hunter)

### Summary
${bug.description}

### Severity
**${bug.severity.toUpperCase()}** - ${bug.category}

### URL
\`${bug.url}\`

### Steps to Reproduce
${bug.stepsToReproduce.map((s, i) => `${i + 1}. ${s}`).join('\n')}

### Expected Behavior
${bug.expectedBehavior}

### Actual Behavior
${bug.actualBehavior}

### Root Cause Analysis
- **Type:** ${bug.rootCause.type}
- **File:** \`${bug.rootCause.file}\`${bug.rootCause.line ? `:${bug.rootCause.line}` : ''}
- **Confidence:** ${(bug.rootCause.confidence * 100).toFixed(0)}%
- **Hypothesis:** ${bug.rootCause.hypothesis}

### Evidence
${bug.rootCause.evidence.map((e) => `- ${e}`).join('\n')}

${bug.rootCause.codeContext ? `### Code Context\n\`\`\`typescript\n${bug.rootCause.codeContext}\n\`\`\`` : ''}

### Suggested Fix
${bug.suggestedFix.description}

${bug.suggestedFix.codeChanges.length > 0 ? `### Code Changes Required\n${bug.suggestedFix.codeChanges.map((c) => `- ${c.file}: ${c.description}`).join('\n')}` : ''}

### Console Errors
${bug.consoleErrors.length > 0 ? bug.consoleErrors.map((e) => `\`\`\`\n${e}\n\`\`\``).join('\n') : 'None'}

### Network Errors
${bug.networkErrors.length > 0 ? bug.networkErrors.map((e) => `- ${e}`).join('\n') : 'None'}

---
*This issue was automatically generated by the Bug Hunter system.*
*Bug ID: ${bug.id}*
*Hash: ${bug.hash}*
`;
  }

  private getLabelsForBug(bug: DiagnosedBug): string[] {
    const labels = ['bug', 'auto-generated'];

    // Severity labels
    if (bug.severity === 'critical') labels.push('priority: critical');
    else if (bug.severity === 'high') labels.push('priority: high');

    // Category labels
    if (bug.rootCause.type === 'frontend') labels.push('frontend');
    else if (bug.rootCause.type === 'backend') labels.push('backend');
    else if (bug.rootCause.type === 'database') labels.push('database');

    return labels;
  }

  private escapeForShell(str: string): string {
    return str.replace(/"/g, '\\"').replace(/`/g, '\\`').replace(/\$/g, '\\$');
  }

  // ============================================================================
  // FILE-BASED REPORTS
  // ============================================================================

  async saveBugReport(bug: DiagnosedBug): Promise<string> {
    await fs.mkdir(this.reportDir, { recursive: true });

    const filename = `bug-${bug.id}.json`;
    const filepath = path.join(this.reportDir, filename);

    await fs.writeFile(filepath, JSON.stringify(bug, null, 2));
    return filepath;
  }

  async saveFixResult(result: FixResult): Promise<string> {
    const fixesDir = path.join(this.reportDir, 'fixes');
    await fs.mkdir(fixesDir, { recursive: true });

    const filename = `fix-${result.bugId}.json`;
    const filepath = path.join(fixesDir, filename);

    await fs.writeFile(filepath, JSON.stringify(result, null, 2));
    return filepath;
  }

  async updateFixesLog(result: FixResult): Promise<void> {
    const logPath = path.join(this.reportDir, 'fixes.json');

    let fixes: FixResult[] = [];
    try {
      const content = await fs.readFile(logPath, 'utf-8');
      fixes = JSON.parse(content);
    } catch {
      // File doesn't exist yet
    }

    fixes.push(result);
    await fs.writeFile(logPath, JSON.stringify(fixes, null, 2));
  }

  // ============================================================================
  // KNOWN BUGS DOCUMENTATION
  // ============================================================================

  async updateKnownBugsDocs(bugs: DiagnosedBug[]): Promise<void> {
    const docsPath = path.join(this.projectRoot, 'docs', 'KNOWN-BUGS.md');

    let content = `# Known Bugs

> Last updated: ${new Date().toISOString()}
> Generated by Bug Hunter

## Overview

| Severity | Count |
|----------|-------|
| Critical | ${bugs.filter((b) => b.severity === 'critical').length} |
| High | ${bugs.filter((b) => b.severity === 'high').length} |
| Medium | ${bugs.filter((b) => b.severity === 'medium').length} |
| Low | ${bugs.filter((b) => b.severity === 'low').length} |

## Active Bugs

`;

    // Group by severity
    const bySeverity = {
      critical: bugs.filter((b) => b.severity === 'critical' && b.fixStatus === 'pending'),
      high: bugs.filter((b) => b.severity === 'high' && b.fixStatus === 'pending'),
      medium: bugs.filter((b) => b.severity === 'medium' && b.fixStatus === 'pending'),
      low: bugs.filter((b) => b.severity === 'low' && b.fixStatus === 'pending'),
    };

    for (const [severity, severityBugs] of Object.entries(bySeverity)) {
      if (severityBugs.length === 0) continue;

      content += `### ${severity.charAt(0).toUpperCase() + severity.slice(1)} Priority\n\n`;

      for (const bug of severityBugs) {
        content += `#### ${bug.title}\n\n`;
        content += `- **ID:** \`${bug.id}\`\n`;
        content += `- **URL:** ${bug.url}\n`;
        content += `- **Root Cause:** ${bug.rootCause.hypothesis}\n`;
        content += `- **File:** \`${bug.rootCause.file}\`\n`;
        if (bug.githubIssue) {
          content += `- **GitHub Issue:** ${bug.githubIssue}\n`;
        }
        content += '\n';
      }
    }

    // Add fixed bugs section
    const fixedBugs = bugs.filter((b) => b.fixStatus === 'fixed');
    if (fixedBugs.length > 0) {
      content += `## Recently Fixed\n\n`;
      for (const bug of fixedBugs.slice(0, 10)) {
        content += `- ~~${bug.title}~~ (${bug.fixedAt})\n`;
      }
    }

    await fs.writeFile(docsPath, content);
  }

  // ============================================================================
  // DAILY REPORTS
  // ============================================================================

  async generateDailyReport(
    bugsFound: DiagnosedBug[],
    fixResults: FixResult[],
    metrics: Partial<BugHunterMetrics>
  ): Promise<string> {
    const date = new Date().toISOString().split('T')[0];
    const dailyDir = path.join(this.reportDir, 'daily');
    await fs.mkdir(dailyDir, { recursive: true });

    const report = {
      date,
      generatedAt: new Date().toISOString(),
      summary: {
        bugsFound: bugsFound.length,
        bugsFixed: fixResults.filter((r) => r.success).length,
        bugsFailed: fixResults.filter((r) => !r.success).length,
        rollbacks: fixResults.filter((r) => r.status === 'rolled_back').length,
      },
      bySeverity: {
        critical: bugsFound.filter((b) => b.severity === 'critical').length,
        high: bugsFound.filter((b) => b.severity === 'high').length,
        medium: bugsFound.filter((b) => b.severity === 'medium').length,
        low: bugsFound.filter((b) => b.severity === 'low').length,
      },
      byType: {
        frontend: bugsFound.filter((b) => b.rootCause.type === 'frontend').length,
        backend: bugsFound.filter((b) => b.rootCause.type === 'backend').length,
        database: bugsFound.filter((b) => b.rootCause.type === 'database').length,
        integration: bugsFound.filter((b) => b.rootCause.type === 'integration').length,
      },
      bugs: bugsFound.map((b) => ({
        id: b.id,
        title: b.title,
        severity: b.severity,
        status: b.fixStatus,
        url: b.url,
      })),
      fixes: fixResults.map((r) => ({
        bugId: r.bugId,
        success: r.success,
        duration: r.duration,
        filesChanged: r.filesChanged.length,
      })),
      metrics,
    };

    const filepath = path.join(dailyDir, `${date}.json`);
    await fs.writeFile(filepath, JSON.stringify(report, null, 2));

    // Also generate markdown version
    const markdownPath = path.join(dailyDir, `${date}.md`);
    await fs.writeFile(markdownPath, this.generateMarkdownReport(report));

    return filepath;
  }

  private generateMarkdownReport(report: {
    date: string;
    generatedAt: string;
    summary: {
      bugsFound: number;
      bugsFixed: number;
      bugsFailed: number;
      rollbacks: number;
    };
    bySeverity: {
      critical: number;
      high: number;
      medium: number;
      low: number;
    };
    byType: Record<string, number>;
    bugs: Array<{
      id: string;
      title: string;
      severity: string;
      status: string;
      url: string;
    }>;
    fixes: Array<{
      bugId: string;
      success: boolean;
      duration: number;
      filesChanged: number;
    }>;
    metrics: Partial<BugHunterMetrics>;
  }): string {
    return `# Bug Hunter Daily Report - ${report.date}

Generated: ${report.generatedAt}

## Summary

| Metric | Value |
|--------|-------|
| Bugs Found | ${report.summary.bugsFound} |
| Bugs Fixed | ${report.summary.bugsFixed} |
| Fix Failures | ${report.summary.bugsFailed} |
| Rollbacks | ${report.summary.rollbacks} |

## By Severity

| Severity | Count |
|----------|-------|
| Critical | ${report.bySeverity.critical} |
| High | ${report.bySeverity.high} |
| Medium | ${report.bySeverity.medium} |
| Low | ${report.bySeverity.low} |

## By Type

| Type | Count |
|------|-------|
${Object.entries(report.byType).map(([type, count]) => `| ${type} | ${count} |`).join('\n')}

## Bugs Found

${report.bugs.length === 0 ? 'No bugs found this cycle.' : ''}
${report.bugs.map((b) => `- **[${b.severity.toUpperCase()}]** ${b.title} (${b.status})`).join('\n')}

## Fixes Applied

${report.fixes.length === 0 ? 'No fixes applied this cycle.' : ''}
${report.fixes.map((f) => `- ${f.bugId}: ${f.success ? '‚úÖ' : '‚ùå'} (${f.duration}ms, ${f.filesChanged} files)`).join('\n')}

---
*Generated by Bug Hunter Autonomous System*
`;
  }

  // ============================================================================
  // METRICS TRACKING
  // ============================================================================

  async updateMetrics(partial: Partial<BugHunterMetrics>): Promise<BugHunterMetrics> {
    const metricsPath = path.join(this.reportDir, '..', 'data', 'metrics.json');

    let metrics: BugHunterMetrics;
    try {
      const content = await fs.readFile(metricsPath, 'utf-8');
      metrics = JSON.parse(content);
    } catch {
      metrics = this.getDefaultMetrics();
    }

    // Update metrics
    metrics = { ...metrics, ...partial };

    // Update daily stats
    const today = new Date().toISOString().split('T')[0];
    const todayStats = metrics.dailyStats.find((s) => s.date === today);

    if (todayStats) {
      if (partial.totalBugsFound !== undefined) {
        todayStats.bugsFound += partial.totalBugsFound - (metrics.totalBugsFound || 0);
      }
      if (partial.totalBugsFixed !== undefined) {
        todayStats.bugsFixed += partial.totalBugsFixed - (metrics.totalBugsFixed || 0);
      }
    } else {
      metrics.dailyStats.push({
        date: today,
        bugsFound: partial.totalBugsFound || 0,
        bugsFixed: partial.totalBugsFixed || 0,
        rollbacks: partial.totalRollbacks || 0,
        cyclesRun: partial.cyclesCompleted || 0,
        humanInterventions: partial.humanInterventions || 0,
      });
    }

    // Keep only last 30 days
    metrics.dailyStats = metrics.dailyStats.slice(-30);

    await fs.mkdir(path.dirname(metricsPath), { recursive: true });
    await fs.writeFile(metricsPath, JSON.stringify(metrics, null, 2));

    return metrics;
  }

  private getDefaultMetrics(): BugHunterMetrics {
    return {
      totalBugsFound: 0,
      totalBugsFixed: 0,
      totalRollbacks: 0,
      autoFixSuccessRate: 0,
      meanTimeToDetection: 0,
      meanTimeToFix: 0,
      humanInterventions: 0,
      cyclesCompleted: 0,
      lastCycleAt: new Date().toISOString(),
      bugsByCategory: {
        crash: 0,
        error: 0,
        ui: 0,
        network: 0,
        performance: 0,
        accessibility: 0,
        security: 0,
      },
      bugsBySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
      },
      dailyStats: [],
    };
  }

  // ============================================================================
  // CONSOLE OUTPUT
  // ============================================================================

  logBugFound(bug: DiagnosedBug): void {
    const severityColors: Record<string, string> = {
      critical: '\x1b[31m', // Red
      high: '\x1b[33m',     // Yellow
      medium: '\x1b[36m',   // Cyan
      low: '\x1b[37m',      // White
    };
    const reset = '\x1b[0m';
    const color = severityColors[bug.severity] || reset;

    console.log(`${color}‚ùå [${bug.severity.toUpperCase()}]${reset} ${bug.title}`);
    console.log(`   ‚îî‚îÄ ${bug.rootCause.hypothesis}`);
    console.log(`   ‚îî‚îÄ File: ${bug.rootCause.file}`);
  }

  logFixResult(result: FixResult): void {
    const icon = result.success ? '‚úÖ' : '‚ùå';
    const status = result.success ? 'FIXED' : 'FAILED';

    console.log(`${icon} [${status}] Bug ${result.bugId}`);
    if (result.success) {
      console.log(`   ‚îî‚îÄ Files changed: ${result.filesChanged.join(', ')}`);
      console.log(`   ‚îî‚îÄ Duration: ${result.duration}ms`);
    } else {
      console.log(`   ‚îî‚îÄ Errors: ${result.errors.join(', ')}`);
    }
  }

  logCycleSummary(bugsFound: number, bugsFixed: number, rollbacks: number): void {
    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üìä Cycle Summary');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`   Bugs Found:    ${bugsFound}`);
    console.log(`   Bugs Fixed:    ${bugsFixed}`);
    console.log(`   Rollbacks:     ${rollbacks}`);
    console.log(`   Success Rate:  ${bugsFound > 0 ? ((bugsFixed / bugsFound) * 100).toFixed(1) : 0}%`);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
  }
}

// ============================================================================
// EXPORT UTILITIES
// ============================================================================

export async function createBugReporter(reportDir: string, projectRoot: string): Promise<BugReporter> {
  await fs.mkdir(reportDir, { recursive: true });
  return new BugReporter(reportDir, projectRoot);
}
